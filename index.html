<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Extension Patch Generator</title>
  <meta property="og:title" content="Patch Generator" />
  <meta property="og:description" content="Generate patches for turbowarp extensions (for extdev's!)" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://surv.is-a.dev/" />
  <style>
    .bump,.sub {
      margin-left: 17px;
    }
    .sub {
      padding: 3px;
      border: 2px dashed black;
      width: fit-content;
    }
  </style>
</head>
<body>
  <h3>Patch Generator :3</h3>
  <div id="options">
    <label>Extension ID: <input data-for="extId" type="text"/></label><br/>
    <br/>
    <label><input data-for="block/inline" type="checkbox"/> BlockType.INLINE?</label><br/>
    <label><input data-for="add/blockShape" type="checkbox"/> Scratch.BlockShape?</label><br/>
    <br/>
    <label><input data-for="block/outputShape" type="checkbox"/> Block.outputShape?</label><br/>
    <label><input data-for="block/output" type="checkbox"/> Block.output?</label><br/>
    <label><input data-for="menu/outputShape" type="checkbox"/> Menu.outputShape?</label><br/>
    <label><input data-for="menu/output" type="checkbox"/> Menu.output?</label><br/>
    <br/>
    <label><input data-for="arg/wxhInlineImage" type="checkbox"/> Argument.InlineImage.WIDTH&HEIGHT?</label><br/>
    <label><input data-for="arg/shadowArgs" type="checkbox"/> Argument.shadow?</label><br/>
    <br/>
    <label><input data-for="block/terminalHats" type="checkbox"/> Allow isTerminal hats</label><br/>
    <br/>
    <label><input data-for="add/patchFns" type="checkbox"/> Add Patch FN's</label><br/>
    <label><input data-for="add/tooltipAPI" type="checkbox"/> Add Tooltip API?</label><br/>
    <label><input data-for="add/fieldSupport" type="checkbox"/> Add Custom Field Support</label><br/>
    <br/>
    <label><input data-for="block/duplicateOnDrag" type="checkbox"/> Duplicate shadow on drag []</label><br/>
    <div data-for="block/duplicateOnDrag/container" style="display: none;">
      <div class="sub">
        <span>Seperate the opcodes with commas.</span><br/>
        <textarea data-for="block/duplicateOnDrag/blocks"></textarea><br/>
        <label><input data-for="block/duplicateOnDrag/fullOpcodes" type="checkbox"/> Full opcodes?</label>
      </div>
      <br/>
    </div>
  </div>
  <div id="output_container">
    <button onclick="gen()">Generate JS!</button>
    <hr/>
    <span>Output: <br/></span>
    <textarea data-for="gen/output"></textarea>
    <br/>
    <label><input data-for="gen/minify" type="checkbox"/> Minify JS?</label><br/>
  </div>
  <script defer>
    function sanitize(str) {
      return str.replaceAll('\\', '\\\\').replaceAll('"', '\"');
    }
    function generatePatchs(opts) {
      // Some default JS
      let js = `const patcher=((function(Scratch){const extId="${sanitize(opts.extId)}",PATCHES_ID=\`__\${extId}_patches__\`,vm=Scratch.vm,runtime=vm.runtime;let exports;`;
      // Some patches
      let patch = {
        _use(name) {
          const sel = this[name];
          if (sel[0]) return sel.slice(1).join('');
          else return '';
        },
        exports: [false, 'exports={', '};'],
        cbfsb: [false, 'const _cbfsb=runtime._convertBlockForScratchBlocks;runtime._convertBlockForScratchBlocks=function(blockInfo,categoryInfo){','const res=_cbfsb.call(this,blockInfo,categoryInfo);','return res};'],
        bmfsb: [false, 'const _bmfsb=runtime._buildMenuForScratchBlocks;runtime._buildMenuForScratchBlocks=function(menuName,menuInfo,categoryInfo){', 'const res=_bmfsb.call(this);', 'return res};'],
        ciij: [false, 'const _ciij=runtime._constructInlineImageJson;runtime._constructInlineImageJson=function(argInfo){','const res=_ciij.call(this,argInfo);','return res;};'],
        blockly: [false, 'Scratch.gui.getBlockly().then(ScratchBlocks=>{const Blockly=ScratchBlocks;','});'],
      };
      let depenancies = {
        hasOwn: [false, 'const hasOwn=(obj,prop)=>Object.prototype.hasOwnProperty.call(obj,prop);'],
        load: [false, ''],
      };
      if (opts.inlineBlock) {
        js += 'Scratch.BlockType.INLINE="INLINE";';
        patch.cbfsb[0] = true;
        patch.cbfsb[1] += 'if(blockInfo.blockType==="INLINE")blockInfo.blockType=Scratch.BlockType.BOOLEAN,blockInfo.outputShape=3,blockInfo.allowDropAnywhere=true,blockInfo.branchCount=blockInfo.branchCount??1;';
        opts.block_outputShape = true;
      }
      if (opts.block_outputShape) {
        patch.cbfsb[0] = true;
        depenancies.hasOwn[0] = true;
        patch.cbfsb[2] += 'if(hasOwn(blockInfo,"outputShape"))res.json.outputShape=blockInfo.outputShape;';
      }
      if (opts.block_output) {
        patch.cbfsb[0] = true;
        depenancies.hasOwn[0] = true;
        patch.cbfsb[2] += 'if(hasOwn(blockInfo,"output"))res.json.output=blockInfo.output,res.json.check_=blockInfo.output;';
      }
      if (opts.menu_outputShape) {
        patch.bmfsb[0] = true;
        depenancies.hasOwn[0] = true;
        patch.bmfsb[2] += 'if(hasOwn(menuInfo,"outputShape"))res.json.outputShape=menuInfo.outputShape;';
      }
      if (opts.menu_output) {
        patch.bmfsb[0] = true;
        depenancies.hasOwn[0] = true;
        patch.bmfsb[2] += 'if(hasOwn(menuInfo,"output"))res.json.output=menuInfo.output,res.json.check_=menuInfo.output;';
      }
      if (opts.terminalHats) {
        patch.cbfsb[0] = true;
        patch.cbfsb[2] += 'if(blockInfo.isTerminal&&(blockInfo.blockType===Scratch.BlockType.HAT||blockInfo.blockType===Scratch.BlockType.EVENT))res.json.nextStatement=undefined;';
      }
      if (opts.export_patchFn) {
        patch.exports[0] = true;
        patch.exports[1] += 'patch(obj,funcs){obj.patches={};Object.keys(funcs).forEach((key)=>{obj.patches[key]=obj[key].bind(obj);obj[key]=function(...args){this["$"+key]=obj.patches[key];funcs[key].call(this,...args);};});},cst_patch(obj,functions){if(obj[PATCHES_ID])return;obj[PATCHES_ID]={};for(const name in functions){const original=obj[name];obj[PATCHES_ID][name]=obj[name];if(original){obj[name]=function(...args){const callOriginal=(...args)=>original.call(this,...args);return functions[name].call(this,callOriginal,...args)};}else{obj[name]=function(...args){return functions[name].call(this,()=>{},...args)};}}},unpatchCst(obj){if(typeof obj[PATCHES_ID]!=="object")return;for(const patch in Object.keys(obj[PATCHES_ID])){const patched=obj[PATCHES_ID][patch];obj[patch]=patched;};obj[PATCHES_ID]=undefined;},';
      }
      if (opts.customFieldSupport) {
        depenancies.hasOwn[0] = true;
        depenancies.load[0] = true;
        depenancies.load[1] += 'const bcfi=runtime._buildCustomFieldInfo.bind(runtime),bcftfsb=runtime._buildCustomFieldTypeForScratchBlocks.bind(runtime);let fi=null;runtime._buildCustomFieldInfo=function(fieldName,fieldInfo,extensionId,categoryInfo){fi=fieldInfo;return bcfi(fieldName,fieldInfo,extensionId,categoryInfo)};runtime._buildCustomFieldTypeForScratchBlocks=function(fieldName,output,outputShape,categoryInfo){let res=bcftfsb(fieldName,output,outputShape,categoryInfo);if(fi){if(fi.color1)res.json.colour=fi.color1;if(fi.color2)res.json.colourSecondary=fi.color2;if(fi.color3)res.json.colourTertiary=fi.color3;if(hasOwn(fi,"output"))res.json.output=fi.output;fi=null;};return res;};';
      }
      if (opts.addBlockShape) {
        depenancies.load[0] = true;
        depenancies.load[1] += 'Scratch.BlockShape=Scratch?.BlockShape??{HEXAGON:1,ROUND:2,SQUARE:3};';
      }
      if (opts.customInlineImageSize) {
        patch.ciij[0] = true;
        patch.ciij[2] += 'res.width=argInfo?.width??24,res.height=argInfo?.height??res.width;';
      }
      if (opts.duplicatingBlocks.bool) {
        const opcodes = opts.duplicatingBlocks.opcodes.split(',').map(opcode => `"${sanitize(`${(opts.duplicatingBlocks.fullOpcodes?'':opts.extId+'_')}${opcode.trim()}`)}"`);
        if (opcodes[0].trim() !== `"${sanitize(`${opts.extId}_`)}"`) {
          patch.blockly[0] = true;
          patch.blockly[1] += `const $dbod=[${opcodes}],sbuisar=Blockly.scratchBlocksUtils.isShadowArgumentReporter;Blockly.scratchBlocksUtils.isShadowArgumentReporter=function(block){return(sbuisar.call(this,block)||block.isShadow()&&$dbod.includes(block.type))};`;
        }
      }
      const depend = (key) => {
        const entry = depenancies[key];
        if (entry[0] && entry[1]) {
          js += entry[1];
        }
        for (const need of (entry?.[2]??[])) {
          depend(need);
        }
      };
      const ALL_DEPENDS = Object.keys(depenancies);
      for (const need of ALL_DEPENDS) {
        depend(need);
      }
      js += patch._use('blockly');
      js += patch._use('cbfsb');
      js += patch._use('bmfsb');
      js += patch._use('ciij');
      js += patch._use('exports');
      // Some more default JS
      js += 'return exports;})(Scratch));';
      return js;
    }
    const sel = (for_) => document.querySelector(`*[data-for="${for_}"]`);
    sel('block/duplicateOnDrag').onchange = function() {
      sel('block/duplicateOnDrag/container').style.display = this.checked ? 'initial' : 'none';
    };
    function makeOptions() {
      const res = {
        extId: sel('extId').value,
        inlineBlock: sel('block/inline').checked,
        block_outputShape: sel('block/outputShape').checked,
        block_output: sel('block/output').checked,
        menu_outputShape: sel('menu/outputShape').checked,
        menu_output: sel('menu/output').checked,
        terminalHats: sel('block/terminalHats').checked,
        customFieldSupport: sel('add/fieldSupport').checked,
        export_patchFn: sel('add/patchFns').checked,
        customInlineImageSize: sel('arg/wxhInlineImage').checked,
        addBlockShape: sel('add/blockShape').checked,
        duplicatingBlocks: { bool: sel('block/duplicateOnDrag').checked, opcodes: sel('block/duplicateOnDrag/blocks').value, fullOpcodes: sel('block/duplicateOnDrag/fullOpcodes').checked },
      };
      return res;
    }
    async function gen() {
      let js = generatePatchs(makeOptions());
      const minify = sel('gen/minify').checked, output = sel('gen/output');
      if (minify && js.length <= 4e6) {
        output.value = '// Minifying... //';
        try {
          const req = await fetch('http://localhost:8000/https://www.toptal.com/developers/javascript-minifier/api/raw', {
            method: 'POST',
            body:`input=${encodeURIComponent(js)}\nfrom=${encodeURIComponent('PatchGeneratorForTw, By https://github.com/AshimeeAlt/')}`,
            headers: {
              'Content-type': 'application/x-www-form-urlencoded',
            },
          });
          if (req.status !== 200) {
            alert('Failed to minify, outputting unminified JS.\n\nCode: -1');
          } else {
            const text = await req.text();
            if (!text) {
              alert('Failed to minify, outputting unminified JS.\n\nCode: -50');
            } else {
              js = text;
            }
          }
        } catch {
          alert('Failed to minify, outputting unminified JS.\n\nCode: 0');
        }
      } else {
        if (minify) alert('JS was to big to minify :(');
      }
      js = js.replace('function', '/**! Generated by patch generator. https://github.com/AshimeeAlt/PatchGenerator */function');
      output.value = js;
    }
  </script>
</body>
</html>